# Walking-robot

L’objectif général du projet est de minimiser le temps de trajet d’un robot dans un entrepôt. On souhaite récupérer ce temps minimal de trajet ainsi que l’ensemble des mouvements qu’il doit effectuer pour le faire. L’entrepôt est représenté par une grille qui détermine les rails sur lesquels le robot peut se déplacer. Le robot a une forme circulaire de diamètre égale à 1.6m et se déplace sur un rail de façon à ce que ce dernier passe par son centre. Les cases de la grille sont des carrés de surface égale à 1m² et les rails sont situés entre ces dernières. Longer les bords de la grille ou un obstacle reviendrait donc à avoir 0.8m dans un mur ou un obstacle, ce qui est impossible. Les bords de la grille ne sont donc pas empruntables par le robot. Enfin, le robot ne peut se déplacer que dans la direction vers laquelle il fait face, il peut changer de direction aux croisements de rails.

A partir d’une grille, on peut facilement obtenir une modélisation du problème en un graphe orienté : 
	- Chaque croisement de la grille est un sommet à condition qu’aucune case participant à ce croisement soit un obstacle. 
	- Chaque sommet existe en 4 exemplaires, un pour chaque orientation.
	- Chaque mouvement possible (qui ne mène ni à un bord ni à un obstacle) à partir d’un sommet est une arête de poids 1.

### Méthode de résolution
La méthode de résolution choisie est l’algorithme de Dijkstra. Toutes les arêtes sont ont un poids égal à 1 donc il serait inutile de vouloir résoudre le problème avec un algorithme plus complexe à implémenter comme l’algorithme de Bellman-Ford. L’algorithme de Dijkstra nous permet en effet de récupérer les plus courts chemins d’un point à tous les autres points d’un graphe. On peut donc appliquer cet algorithme à notre graphe orienté présenté précédemment avec notre point de départ et récupérer dans tous les plus courts chemins le plus court chemin vers notre point d’arrivée. Le principe de l’algorithme est le suivant : - On partitionne l'ensemble des sommets en deux ensembles F et T. Les sommets de F sont dits fixés et ceux de T temporaires. - On utilise pour chaque sommet un marquage minDistance(v) égal à la distance minimale depuis le sommet de départ u vers ce sommet v. A chaque étape, la définition de minDistance(v) est la longueur d'un plus court chemin de u vers v dont tous les sommets intermédiaires sont dans F. Initialement, minDistance(u) = 0 et minDistance(v) = +∞ pour tout v ≠ u. - A chaque itération, si ça vaut le coup, v est transféré dans F et on met à jour minDistance(v). Les minDistance des sommets fixés (c'est-à-dire les sommets de F) sont forcément minimales.
Soit n le nombre de sommets. La complexité de l'algorithme de Dijkstra sous cette forme est O(5n). En effet, à chaque étape, on transfère un noeud de T vers F, ce qui nous fait n itérations. A l'intérieur de chaque itération, on recherche le sommet de T qui possède la plus petite distance temporaire, opération en O(5) dans le pire des cas (car au maximum 5 mouvements possibles à partir de tout sommet).